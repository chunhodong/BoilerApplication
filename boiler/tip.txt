1. 데이터유효성 검증로직은Dto에 어노테이션으로처리(이메일형식,비밀번호길이 등등,NOT NULL)
   Entity에는 NOT NULL조건만 추가하여, 비즈니스로직에 의존하지 않게 부여

 - Dto에 검증로직을 부여하여 Dto를 사용하는 컨트롤러나 서비스가 코드중복없이 같은 코드를 사용할수있음
   추가적으로 검증로직을 어노테이션으로 대체한다면 간결하게 유효성 검증이가능
 - 로직을 직접 작성안하고 어노테이션으로 했을때 단점은 검증규칙이 복잡할경우 어노테이션으로 대체하기 힘들수있음
   - 이 경우 커스텀 어노테이션 작성을 고려해볼수있음
   - 커스텀 어노테이션을 안쓴다면 서비스클래스에 검증을 작성해야함
     - 커스텀어노테이션이 너무 많으면 가독성이 떨어질수도있음
   - 좋은방법은 DTO에서는 값자체를 검증하고 로직이 필요한 부분은 서비스클래스에서 작성
     - 예를들어 입력값 양수/음수/NULL/최소길이 등은 DTO에작성, 예를들어 입력했을때 특정필드값이 다른 필드보다 커야한다같은
       로직이 필요한경우는 서비스클래스에 코드로작성 아니면 커스텀어노테이션으로 DTO에 작성


 - Entity에는 필요할경우 검증로직을 추가할수있음 Entity에 검증로직을 추가했을때 장점은 개발자의 실수를
   줄여줄수있음, 만약 새로운 기능을 만들고 상위 레이어에서 유효성검증로직을 실수로 안넣었다면 Entity에서 이를 막아줄수있음
   단점은 Entity책임이 늘어나게되고 Entity가 화면영역에 의존하게됨 단 Entity에 로직이
   자체가 필요없는게 아니라 입력데이터의 유효성검증에 경우를 말함
 - 다만 DB칼럼의 유효성규칙에 해당하는 NOT NULL조건은 추가

 - Service Layer도 위에 Entity처럼 검증로직을 추가할순있지만, Entity에서 추가했을때와 같은 문제발생
   하지만 Service Layer에서 검증로직이 필요한 상황이 존재할수있음, 만약 팀 상황상 서비스레이어만 테스트코드를
   작성해야한다면, 무결성을 위해 Service Layer에도 입력값 검증이 필요할수도있음 이때는 자바에서 제공하는 Validator를 이용하면
   모든DTO에 적용가능한 검증로직작성가능

 --------------------------------------------------------------------------------------

 2. 테스트코드

 - TDD를 한다고 했을시 테스트코드성공을위해 프로덕트소스를 고민하는 상황이 발생할수있음
 - 회원의 마지막로그인시간을 갱신하는api개발할때 테스트코드를 작성하지 않는 상황에서 머리속으로 그려본 시나리오는
   회원필드에있는 lastLogin필드를 LocalDateTime.now()로 바꿔주는 메소드를 엔티티에 추가
 - 이 경우 테스트코드를 작성,검증이 상당히번거로움 검증을 위해선 lastLogin필드에있는값이 검증을 위한 입력값하고 똑같아야함
   LocalDateTime.now()는 밀리세컨드 단위까지 나오기때문에 상당히 어려움
 - 해당 케이스는 분단위까지만 검증하는걸로 해결할수 있자만 TDD를하면서 어떻게해야 프로덕트소스를 수정하는걸 생각히자 않고
   기능을 확실하게 검증할수있는지 고민해야함

--------------------------------------------------------------------------------------
3. 예외처리-1
  - 예외는 체크예외 언체크예외 두가지 존재 모든예외는 try-catch로잡거나 throw로 던지거나 둘중하나로 처리해야함
  - 체크예외는 컴파일러가 체크하는 예외, 명시적으로 try-catch로 잡거나 throw를통해서 상위로 던지거나 둘중하나로 처리해야함
  - 언체크예외는 명시적으로 처리하지 않으면 자동으로 상위로 throws함
  - 체크예외는 경우 명시적으로 처리를 해야하기때문에 문제발생가능성 존재
      - 하위계층에서 발생한 예외를 상위계층으로 최상위 계층으로 끝까지 throw를 해버림, 반복적인 코드가 발생
      - 발생하는 예외가 많으질수록 throws에 붙는 예외가 더 늘어나서 코드자체도 복잡해짐
      - throws Exception을통해서 모든예외를 하위에서 throw Exception 해버리면 상위에서는  어떤 예외를 잡았고 어떤 예외를 던지는 알수없음
        더군다나 Exception Advice같은 공통로직에서도 Exception객체로 받기때문에 원인을 파악하기쉽지않음
      - 하위계층에서 예외를 throw해버리고, 상위계층까지 전달됫을때, 이 예외가 특정기술에 종속적인 예외라면, 나머지 계층도 특정기술에 종속적인 코드가 된다.
        - JDBC에서 발생한 SQLException이 컨트롤러까지 도달한상태에서 JDBC를 JPA로 바꾼다면, JDBC에 종속적인 Exception코드를 전부 수정해줘야함
    - 체크예외 문제를 해결하기위한망법을 체크예외를 try-catch한상태에서 언체크드 예외로 감싸서 던지는 방법존재, 언체크드 예외는 명시적으로 기술하지않아도 되기떄문에 코드간 의존관계가
      없고, 반복코드가 필요없음, 언체크드 예외로 던지고 Controller Advice같은 공통처리 로직에서 한번만 처리해주면됨

4. 예외처리-2
  - 스프링은 컨트롤러 밖으로 예외가 던져지면 예외를 감지해서 동작을 새로 정의할수있는 HandlerExceptionResolver를 제공
  - 스프링부트가 실행되면 HandlerExceptionResolver구현체를 기본적으로 등록
  - HandlerExceptionResolver가 없다면 컨트롤러에서 발생한예외가 WAS까지 전달된후, WAS에서 다시 에러처리를하기위해
    컨트롤러로 에러처리를 요청
  - 기본으로 등록되는 HandlerExceptionResolver구현체중 ExceptionHandlerExceptionResolver는
    @ExceptionHandler어노테이션이붙은 메소드가 예외처리를 함 @ExceptionHandler어노테이션에서 예외를처리하고 응답데이터를
    다시 정의함, 이때 WAS까지 전달된후에 다시 에러처리를 위해 컨트롤러로 요청하지 않고 바로 응답
  - @ExceptionHandler는 컨트롤러에 종속되있기때문에 비즈니스로직과 예외처리 코드가 한 클래스에 존재
  - @ControllerAdvice를 포함한 클래스를 작성하면 @ExceptionHandler메소드만 빼낼수있음
  - @ControllerAdvice를 사용해서 특정 컨트롤러나 특정패키지만 예외처리를 해줄수있음, 없으면 글로벌하게 예외처리

*. 통계데이터
  - mysql
    - mysql의 실행계획은 select_type,table,partitions,type,possible_keys,key,key_len,ref,rows,filtered,Extra 컬럼이 존재
    - 컬럼에 대한 설명은 https://nomadlee.com/mysql-explain-sql/, https://12bme.tistory.com/168
    - select_type : SELECT쿼리가 어떤 타입인지 나타내는 용도
      - SIMPLE : 단순 SELECT(Union이나 Sub Query가 없는 SELECT문)

    - table : 어떤 테이블에 대한 정보인지 나타냄

    - partitions : 파티셔닝 테이블일때, 어떤 파티션을 읽었는지 알려줌

    - type : 인덱스 참조에 대한 정보
      - ALL : 테이블을 처음부터 끝까지 검색하는 경우, 일반적으로 테이블 풀스캔이라고함

    - possible_keys : 옵티마이저가 쿼리를 처리하기 위해 여러 처리 방법을 고려하던 중에 사용된 후보 인덱스 목록

    - key : possible_keys 컬럼에서 보여진 후보 인덱스 목록 중 실제 사용된 인덱스, 인덱스 사용 못했을 경우는 NULL로 표기된다

    - rows : 옵티마이저가 비용산정을 위해 얼마나 많은 레코드를 읽고 비교해야하는지 예측해본 레코드수
             스토리지 엔진별로 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야하는지를 의미

    - filtered : 스토리지 엔진에서 읽어온 쿼리중에 mysql엔진이 필터링한 비율(통계치라 정확히지않음)

    - extra : MySQL이 어떻게 쿼리를 풀었는지 부가 정보가 나옴
      - using where : where조건으로 데이터를 추출, 대부분 쿼리에서 표시됨, 만약 row칼럼에 데이터와 실제읽어온 데이터의 개수차이가 크다면
                      보완이 필요할 수 있음
  - postgresql

*. 분산트랜잭션

*. db파티셔닝

*. 결제,지도,옵션별제고관리(옵션이존재하는 상품,옵션자체가 없는상품 제고분류)