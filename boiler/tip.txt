1. 데이터유효성 검증로직은Dto에 어노테이션으로처리(이메일형식,비밀번호길이 등등,NOT NULL)
   Entity에는 NOT NULL조건만 추가하여, 비즈니스로직에 의존하지 않게 부여

 - Dto에 검증로직을 부여하여 Dto를 사용하는 컨트롤러나 서비스가 코드중복없이 같은 코드를 사용할수있음
   추가적으로 검증로직을 어노테이션으로 대체한다면 간결하게 유효성 검증이가능
 - 로직을 직접 작성안하고 어노테이션으로 했을때 단점은 검증규칙이 복잡할경우 어노테이션으로 대체하기 힘들수있음
   - 이경우 커스텀 어노테이션 작성을 고려해볼수있음

 - Entity에는 필요할경우 검증로직을 추가할수있음 Entity에 검증로직을 추가했을때 장점은 개발자의 실수를
   줄여줄수있음, 만약 새로운 기능을 만들고 상위 레이어에서 유효성검증로직을 실수로 안넣었다면 Entity에서 이를 막아줄수있음
   단점은 Entity책임이 늘어나게되고 Entity가 화면영역에 의존하게됨 단 Entity에 로직이
   자체가 필요없는게 아니라 입력데이터의 유효성검증에 경우를 말함
 - 다만 DB칼럼의 유효성규칙에 해당하는 NOT NULL조건은 추가

 - Service Layer도 위에 Entity처럼 검증로직을 추가할순있지만, Entity에서 추가했을때와 같은 문제발생
   하지만 Service Layer에서 검증로직이 필요한 상황이 존재할수있음, 만약 팀 상황상 서비스레이어만 테스트코드를
   작성해야한다면, 무결성을 위해 Service Layer에도 입력값 검증이 필요할수도있음 이때는 자바에서 제공하는 Validator를 이용하면
   모든DTO에 적용가능한 검증로직작성가능

 --------------------------------------------------------------------------------------

 2. 테스트코드

 - TDD를 한다고 했을시 테스트코드성공을위해 프로덕트소스를 고민하는 상황이 발생할수있음
 - 회원의 마지막로그인시간을 갱신하는api개발할때 테스트코드를 작성하지 않는 상황에서 머리속으로 그려본 시나리오는
   회원필드에있는 lastLogin필드를 LocalDateTime.now()로 바꿔주는 메소드를 엔티티에 추가
 - 이 경우 테스트코드를 작성,검증이 상당히번거로움 검증을 위해선 lastLogin필드에있는값이 검증을 위한 입력값하고 똑같아야함
   LocalDateTime.now()는 밀리세컨드 단위까지 나오기때문에 상당히 어려움
 - 해당 케이스는 분단위까지만 검증하는걸로 해결할수 있자만 TDD를하면서 어떻게해야 프로덕트소스를 수정하는걸 생각히자 않고
   기능을 확실하게 검증할수있는지 고민해야함

--------------------------------------------------------------------------------------
3. 예외처리
  - 예외는 체크예외 언체크예외 두가지 존재 모든예외는 try-catch로잡거나 throw로 던지거나 둘중하나로 처리해야함
  - 체크예외는 컴파일러가 체크하는 예외, 명시적으로 try-catch로 잡거나 throw를통해서 상위로 던지거나 둘중하나로 처리해야함
  - 언체크예외는 명시적으로 처리하지 않으면 자동으로 상위로 throws함
  - 체크예외는 경우 명시적으로 처리를 해야하기때문에 문제발생가능성 존재
      - 하위계층에서 발생한 예외를 상위계층으로 최상위 계층으로 끝까지 throw를 해버림, 반복적인 코드가 발생
      - 발생하는 예외가 많으질수록 throws에 붙는 예외가 더 늘어나서 코드자체도 복잡해짐
      - throws Exception을통해서 모든예외를 하위에서 throw Exception 해버리면 상위에서는  어떤 예외를 잡았고 어떤 예외를 던지는 알수없음
        더군다나 Exception Advice같은 공통로직에서도 Exception객체로 받기때문에 원인을 파악하기쉽지않음
      - 하위계층에서 예외를 throw해버리고, 상위계층까지 전달됫을때, 이 예외가 특정기술에 종속적인 예외라면, 나머지 계층도 특정기술에 종속적인 코드가 된다.
        - JDBC에서 발생한 SQLException이 컨트롤러까지 도달한상태에서 JDBC를 JPA로 바꾼다면, JDBC에 종속적인 Exception코드를 전부 수정해줘야함
    - 체크예외 문제를 해결하기위한망법을 체크예외를 try-catch한상태에서 언체크드 예외로 감싸서 던지는 방법존재, 언체크드 예외는 명시적으로 기술하지않아도 되기떄문에 코드간 의존관계가
      없고, 반복코드가 필요없음, 언체크드 예외로 던지고 Controller Advice같은 공통처리 로직에서 한번만 처리해주면됨

*. 통계데이터

*. MSA거래

*. mock객체 입력값검증의 필요성

*. DB파티셔닝